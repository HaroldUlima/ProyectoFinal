# ğŸ§  ImplementaciÃ³n del PatrÃ³n Cloud â€“ Convoy Secuencial


## ğŸ“Œ 1. Problema que resuelve el patrÃ³n Convoy Secuencial

En sistemas distribuidos, especialmente aquellos que procesan mensajes en paralelo, surge un problema cuando:

- Se deben procesar mensajes **en orden por grupo** (ej. por cliente o por cuenta).
- El procesamiento de un grupo **bloquea a otros** si se hace secuencialmente.

### â— Ejemplos de problemas:

- Inconsistencias por procesar transacciones fuera de orden.
- Cuellos de botella si un proceso lento detiene todo el flujo.
- Ineficiencia al aplicar bloqueo global en lugar de por grupo.

---

## âœ… 2. SoluciÃ³n que propone el patrÃ³n

El patrÃ³n **Sequential Convoy** permite procesar mensajes relacionados **en orden dentro de su grupo**, pero **sin bloquear otros grupos**. Se basa en:

- AgrupaciÃ³n por claves (por ejemplo, `user_id`, `tenant_id`, `account_id`).
- Particionado de colas o tÃ³picos por clave.
- Procesamiento concurrente entre grupos, pero ordenado dentro de cada uno.

### ğŸ”§ TecnologÃ­as recomendadas:

- Apache Kafka (particiones por clave).
- Azure Service Bus (session-enabled queues).
- AWS Kinesis (shard key).
- RabbitMQ (routing keys).

---

## ğŸ­ 3. Casos de aplicaciÃ³n reales

| Industria   | Caso de uso                              | AplicaciÃ³n del patrÃ³n Convoy Secuencial |
|------------|-------------------------------------------|------------------------------------------|
| Bancaria   | Transacciones por cuenta                  | Mantiene el orden de depÃ³sitos y retiros |
| E-commerce | Pedidos por cliente                       | Asegura consistencia en stock y despacho |
| LogÃ­stica  | Seguimiento de paquetes                   | Procesa eventos en orden por tracking ID |
| SaaS       | Acciones por tenant (cliente empresarial) | AÃ­sla el procesamiento por cliente       |

---

## ğŸ’» Proyecto de ejemplo: Procesamiento de Pedidos por Cliente

Este proyecto simula el procesamiento de pedidos en un sistema Kafka con mÃºltiples particiones. Cada pedido se asocia a un usuario, y se garantiza el orden por usuario.

### ğŸ—‚ï¸ Estructura del proyecto


sequential-convoy/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ producer.js
â””â”€â”€ consumer.js




---

### ğŸ³ docker-compose.yml

```yaml
version: '2'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:7.4.0
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1


ğŸ“¦ producer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "producer", brokers: ["localhost:9092"] });
const producer = kafka.producer();

const sendOrders = async () => {
  await producer.connect();

  const users = ["user1", "user2", "user3"];

  for (let i = 0; i < 10; i++) {
    const user = users[i % users.length];
    const order = {
      orderId: `order-${i}`,
      user,
      timestamp: new Date().toISOString(),
    };

    await producer.send({
      topic: "orders",
      messages: [
        {
          key: user,
          value: JSON.stringify(order),
        },
      ],
    });

    console.log(`ğŸ“¦ Enviado pedido: ${JSON.stringify(order)}`);
  }

  await producer.disconnect();
};

sendOrders();



âœ… consumer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "consumer", brokers: ["localhost:9092"] });

const consumer = kafka.consumer({ groupId: "order-group" });

const run = async () => {
  await consumer.connect();
  await consumer.subscribe({ topic: "orders", fromBeginning: true });

  await consumer.run({
    eachMessage: async ({ topic, partition, message }) => {
      const pedido = JSON.parse(message.value.toString());

      console.log(
        `âœ… Procesando pedido ${pedido.orderId} de ${pedido.user} en particiÃ³n ${partition}`
      );
    },
  });
};

run();

#PASOS ADICIONALES:

## ğŸ§ª Â¿CÃ³mo probarlo?

### ğŸš€ Levanta Kafka y Zookeeper:

```bash
docker-compose up -d

ğŸ“¦ Instala las dependencias:
npm init -y
npm install kafkajs
ğŸ§µ (Opcional) Crea el tÃ³pico si es necesario:
kafka-topics.sh --create --topic orders --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1
ğŸ› ï¸ Ejecuta el consumidor:
node consumer.js
ğŸ“¨ En otra terminal, ejecuta el productor:
node producer.js


ğŸ¯ Resultado Esperado
Los pedidos de cada usuario serÃ¡n procesados en orden (convoy secuencial), pero sin bloquear el procesamiento de otros usuarios gracias al uso de claves (por usuario) y particiones en Kafka.



